#!/usr/bin/env python3
"""
ChatGPT DeepResearch Footnotes to Obsidian Converter.

This script converts markdown footnotes generated by ChatGPT DeepResearch
into Obsidian-compatible footnote format.

Background
----------
ChatGPT DeepResearch generates research reports with footnotes in a specific
format that is not compatible with Obsidian's footnote syntax. This tool
bridges the gap by converting these footnotes automatically.

Input Format (ChatGPT DeepResearch)
-----------------------------------
ChatGPT DeepResearch outputs footnotes in the following format:

Inline references in the body text::

    Some research finding[\\[1\\]](https://example.com/source#:~:text=quote).

Footnote definitions at the end of the document (after '---' separator)::

    ---
    [\\[1\\]](https://example.com/source#:~:text=quote) Source Title
    [https://example.com/source](https://example.com/source)

Output Format (Obsidian)
------------------------
This tool converts to Obsidian's standard footnote format:

Inline references::

    Some research finding[^1].

Footnote definitions::

    [^1]: Source Title https://example.com/source#:~:text=quote

Conversion Behavior
-------------------
- Inline references ``[\\[N\\]](URL)`` are converted to ``[^N]``
- URLs are preserved in full, including fragments (e.g., ``#:~:text=...``)
- If the same footnote number references different URLs, new IDs are
  assigned with alphabetic suffixes (e.g., ``[^1]``, ``[^1a]``, ``[^1b]``)
- Duplicate references to the same URL share the same footnote ID
- The original footnote definition section (after ``---``) is removed
  and replaced with Obsidian-style definitions

Usage
-----
Command line::

    # Convert with default output filename (adds '_obsidian' suffix)
    python chatgpt_deepresearch_to_obsidian.py input.md

    # Specify output filename
    python chatgpt_deepresearch_to_obsidian.py input.md -o output.md

    # Output to stdout
    python chatgpt_deepresearch_to_obsidian.py input.md --stdout

As a module::

    from chatgpt_deepresearch_to_obsidian import convert_footnotes

    content = open('input.md').read()
    converted = convert_footnotes(content)

Examples
--------
Input::

    研究によると重要な発見がありました[\\[1\\]](https://example.com#:~:text=finding)。
    別の研究でも確認されています[\\[1\\]](https://example.com#:~:text=finding)。

    ---
    [\\[1\\]](https://example.com#:~:text=finding) Example Research Paper

    [https://example.com](https://example.com)

Output::

    研究によると重要な発見がありました[^1]。
    別の研究でも確認されています[^1]。

    [^1]: Example Research Paper https://example.com#:~:text=finding

Author
------
Generated with Claude Code assistance.

License
-------
MIT License
"""

import argparse
import re
import sys
from pathlib import Path
from collections import OrderedDict


def parse_footnote_definitions(content: str) -> tuple[str, dict[str, dict]]:
    """
    Parse footnote definitions from the end of the document.

    ChatGPT DeepResearch places footnote definitions after a '---' separator
    at the end of the document. This function extracts those definitions
    and returns the content without them.

    Parameters
    ----------
    content : str
        The full markdown content including footnote definitions.

    Returns
    -------
    tuple[str, dict[str, dict]]
        A tuple containing:
        - str: The content without the footnote definition section
        - dict: A dictionary mapping footnote numbers to their data::

            {
                '1': {'url': 'https://...', 'title': 'Source Title'},
                '2': {'url': 'https://...', 'title': None},
                ...
            }

    Notes
    -----
    The function looks for the '---' separator to identify where the
    footnote definition section begins. If no separator is found,
    the original content is returned unchanged with an empty dictionary.

    The definition section format expected::

        ---
        [\\[1\\]](URL#fragment) Title Text
        [\\[2\\]](URL#fragment) [\\[3\\]](URL#fragment) Shared Title

        [https://example.com](https://example.com)

    Multiple footnote numbers can share the same line if they reference
    the same source.
    """
    lines = content.split('\n')
    footnotes = {}

    # Pattern to match footnote definition lines like:
    # [\[1\]](URL#fragment) Title
    # or multiple refs on one line: [\[1\]](URL) [\[2\]](URL) Title
    ref_pattern = re.compile(r'\[\\\[(\d+)\\\]\]\(([^)]+)\)')

    # Find where footnote definitions section starts (after ---)
    separator_idx = None
    for i, line in enumerate(lines):
        if line.strip() == '---':
            separator_idx = i
            break

    if separator_idx is None:
        return content, {}

    definition_start_idx = separator_idx

    # Parse definition lines
    i = separator_idx + 1
    current_refs = []
    current_title = None
    current_url = None

    while i < len(lines):
        line = lines[i].strip()

        # Skip empty lines
        if not line:
            i += 1
            continue

        # Check if line contains footnote refs
        refs = ref_pattern.findall(line)
        if refs:
            # Save previous entry if exists
            if current_refs and current_url:
                for ref_num in current_refs:
                    if ref_num not in footnotes:
                        footnotes[ref_num] = {
                            'url': current_url,
                            'title': current_title
                        }

            # Extract refs and remaining text (title)
            current_refs = [r[0] for r in refs]
            current_url = refs[0][1]  # Use first URL

            # Remove refs from line to get title
            title = ref_pattern.sub('', line).strip()
            current_title = title if title else None

        # Check if line is a standalone URL like [URL](URL)
        elif line.startswith('[http'):
            url_match = re.match(r'\[([^\]]+)\]\(([^)]+)\)', line)
            if url_match and current_refs:
                # This is the URL line, we already have the URL from the ref
                pass

        i += 1

    # Save last entry
    if current_refs and current_url:
        for ref_num in current_refs:
            if ref_num not in footnotes:
                footnotes[ref_num] = {
                    'url': current_url,
                    'title': current_title
                }

    # Return content up to separator
    content_without_defs = '\n'.join(lines[:definition_start_idx])

    return content_without_defs, footnotes


def convert_inline_references(content: str, footnotes: dict) -> tuple[str, dict]:
    r"""
    Convert inline references from ChatGPT DeepResearch to Obsidian format.

    Transforms ``[\[N\]](URL)`` patterns to ``[^N]`` format. Handles cases
    where the same footnote number references different URLs by assigning
    unique IDs with alphabetic suffixes.

    Parameters
    ----------
    content : str
        The markdown content with inline references to convert.
    footnotes : dict
        Dictionary of footnote definitions parsed from the document end,
        used to retrieve titles for the converted footnotes.

    Returns
    -------
    tuple[str, dict]
        A tuple containing:
        - str: The converted content with Obsidian-style references
        - dict: An OrderedDict mapping new footnote IDs to their data::

            {
                '1': {'url': '...', 'title': '...', 'original_num': '1'},
                '1a': {'url': '...', 'title': '...', 'original_num': '1'},
                '2': {'url': '...', 'title': '...', 'original_num': '2'},
            }

    Notes
    -----
    ID Assignment Logic:
        1. If a URL is seen for the first time, try to use the original
           footnote number as the ID
        2. If the same number is already used with a different URL,
           append alphabetic suffixes: 'a', 'b', 'c', etc.
        3. If the same URL appears multiple times, reuse the same ID

    Examples
    --------
    Same number, same URL (shares ID)::

        Input:  text[\[1\]](url1) more[\[1\]](url1)
        Output: text[^1] more[^1]

    Same number, different URLs (gets new ID)::

        Input:  text[\[1\]](url1) more[\[1\]](url2)
        Output: text[^1] more[^1a]
    """
    # Pattern to match inline refs: [\[number\]](URL)
    inline_pattern = re.compile(r'\[\\\[(\d+)\\\]\]\(([^)]+)\)')

    # Track URL -> ID mapping
    url_to_id = {}
    id_to_data = OrderedDict()

    def replace_ref(match):
        ref_num = match.group(1)
        url = match.group(2)

        # Create unique key from URL
        if url in url_to_id:
            ref_id = url_to_id[url]
        else:
            # Assign new ID
            # First, try to use the original number
            if ref_num not in [data.get('original_num') for data in id_to_data.values()]:
                # Check if this number is already used with a different URL
                used = False
                for existing_id, data in id_to_data.items():
                    if existing_id == ref_num and data['url'] != url:
                        used = True
                        break

                if not used and ref_num not in id_to_data:
                    ref_id = ref_num
                else:
                    # Find suffix
                    suffix = 'a'
                    while f"{ref_num}{suffix}" in id_to_data:
                        suffix = chr(ord(suffix) + 1)
                    ref_id = f"{ref_num}{suffix}"
            else:
                # Find suffix
                suffix = 'a'
                while f"{ref_num}{suffix}" in id_to_data:
                    suffix = chr(ord(suffix) + 1)
                ref_id = f"{ref_num}{suffix}"

            url_to_id[url] = ref_id

            # Get title from parsed definitions if available
            title = footnotes.get(ref_num, {}).get('title')

            id_to_data[ref_id] = {
                'url': url,
                'title': title,
                'original_num': ref_num
            }

        return f'[^{ref_id}]'

    converted = inline_pattern.sub(replace_ref, content)

    return converted, id_to_data


def generate_footnote_definitions(footnote_data: dict) -> str:
    """
    Generate Obsidian-style footnote definitions.

    Creates the footnote definition section in Obsidian's format,
    with each footnote on its own line.

    Parameters
    ----------
    footnote_data : dict
        Dictionary mapping footnote IDs to their data, containing
        'url' and optionally 'title' keys.

    Returns
    -------
    str
        The formatted footnote definitions, including leading blank lines.
        Returns empty string if no footnotes.

    Notes
    -----
    Output format for each footnote::

        [^ID]: Title URL

    If no title is available::

        [^ID]: URL

    The definitions are preceded by two blank lines to separate them
    from the main content.

    Examples
    --------
    >>> data = {
    ...     '1': {'url': 'https://example.com', 'title': 'Example'},
    ...     '2': {'url': 'https://other.com', 'title': None}
    ... }
    >>> print(generate_footnote_definitions(data))


    [^1]: Example https://example.com
    [^2]: https://other.com
    """
    if not footnote_data:
        return ''

    lines = ['', '']  # Add blank lines before footnotes

    for ref_id, data in footnote_data.items():
        url = data['url']
        title = data.get('title')

        if title:
            lines.append(f'[^{ref_id}]: {title} {url}')
        else:
            lines.append(f'[^{ref_id}]: {url}')

    return '\n'.join(lines)


def convert_footnotes(content: str) -> str:
    """
    Convert ChatGPT DeepResearch footnotes to Obsidian format.

    This is the main conversion function that orchestrates the full
    transformation process.

    Parameters
    ----------
    content : str
        The full markdown content from ChatGPT DeepResearch output.

    Returns
    -------
    str
        The converted markdown with Obsidian-compatible footnotes.

    Notes
    -----
    Processing steps:
        1. Parse and extract footnote definitions from document end
        2. Convert inline references to Obsidian format
        3. Handle duplicate URL references with shared IDs
        4. Generate new Obsidian-style footnote definitions
        5. Combine converted content with new definitions

    Examples
    --------
    >>> content = '''
    ... Text with reference[\\[1\\]](https://example.com).
    ...
    ... ---
    ... [\\[1\\]](https://example.com) Example Source
    ... '''
    >>> print(convert_footnotes(content))
    Text with reference[^1].

    [^1]: Example Source https://example.com
    """
    # Parse existing footnote definitions
    content_without_defs, footnotes = parse_footnote_definitions(content)

    # Convert inline references
    converted_content, footnote_data = convert_inline_references(
        content_without_defs, footnotes
    )

    # Remove trailing whitespace from content
    converted_content = converted_content.rstrip()

    # Generate new footnote definitions
    new_definitions = generate_footnote_definitions(footnote_data)

    return converted_content + new_definitions + '\n'


def main():
    """
    Command-line interface for the footnote converter.

    Parses command-line arguments and executes the conversion.

    Arguments
    ---------
    input : path
        Path to the input markdown file.
    -o, --output : path, optional
        Path for the output file. If not specified, creates a file
        with '_obsidian' suffix added to the input filename.
    --stdout : flag
        Output to stdout instead of writing to a file.

    Exit Codes
    ----------
    0 : Success
    1 : Input file not found

    Examples
    --------
    Convert with default output name::

        $ python chatgpt_deepresearch_to_obsidian.py report.md
        Converted: report.md -> report_obsidian.md

    Specify output filename::

        $ python chatgpt_deepresearch_to_obsidian.py report.md -o converted.md
        Converted: report.md -> converted.md

    Output to stdout for piping::

        $ python chatgpt_deepresearch_to_obsidian.py report.md --stdout | head
    """
    parser = argparse.ArgumentParser(
        description='Convert ChatGPT DeepResearch footnotes to Obsidian format',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  %(prog)s input.md                    Convert with default output name
  %(prog)s input.md -o output.md       Specify output filename
  %(prog)s input.md --stdout           Output to stdout
        '''
    )
    parser.add_argument(
        'input',
        type=Path,
        help='Input markdown file (ChatGPT DeepResearch output)'
    )
    parser.add_argument(
        '-o', '--output',
        type=Path,
        help='Output file (default: input_obsidian.md)'
    )
    parser.add_argument(
        '--stdout',
        action='store_true',
        help='Output to stdout instead of file'
    )

    args = parser.parse_args()

    # Read input file
    if not args.input.exists():
        print(f"Error: File not found: {args.input}", file=sys.stderr)
        sys.exit(1)

    content = args.input.read_text(encoding='utf-8')

    # Convert
    converted = convert_footnotes(content)

    # Output
    if args.stdout:
        print(converted)
    else:
        output_path = args.output or args.input.with_stem(args.input.stem + '_obsidian')
        output_path.write_text(converted, encoding='utf-8')
        print(f"Converted: {args.input} -> {output_path}")


if __name__ == '__main__':
    main()
